import os
os.system('pip install python-telegram-bot')
import uuid
import string
import random

import logging
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telegram import InlineKeyboardButton, InlineKeyboardMarkup


TOKEN = "8385486489:AAGyZGUk5Xa1yI6Qkt-b0KZhczinimJoNh4"
#channel username without @
channel='nagiportal'
#developer username without @
developer='nagipy'

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

try:
    import requests
except ImportError:
    os.system("pip install requests")
    import requests

class InstagramPasswordResetBot:
    def __init__(self, token: str):
        self.application = Application.builder().token(token).build()
        self.setup_handlers()
    
    def setup_handlers(self):
        # Command handlers
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("reset", self.reset_command))
        
        # Message handler for email/username input
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_input))
        

    from telegram import InputFile

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Send a welcome message and user's profile picture (if available) when /start is issued."""
        user = update.effective_user

        welcome_text = f"""
    üòÑHeyy ‚Ä¢ {user.full_name}
    *Welcome ‚ö°Ô∏è To Instagram Reset Bot ü§ßüéÄ*

    - *DEVELOPER :* @nagipy 
    - *CHANNEL :* @redirectd

    *24/7 ACTIVE RESET BOT BY* [NAGI](https://t.me/nagipy)

    - *Send:* /reset <username/email> - Reset password for specific account
    - *Type:* /reset <username or gmail>
    """

        keyboard = [
            [
                InlineKeyboardButton("üì¢ Channel", url="https://t.me/redirectd"),
                InlineKeyboardButton("üë®‚Äçüíª Developer", url="https://t.me/nagipy")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        try:
            # Get the highest resolution profile photo of the user
            photos = await context.bot.get_user_profile_photos(user.id, limit=1)
            if photos.total_count > 0:
                photo_file_id = photos.photos[0][-1].file_id  # Use highest resolution
                await update.message.reply_photo(
                    photo=photo_file_id,
                    caption=welcome_text,
                    parse_mode='Markdown',
                    reply_markup=reply_markup
                )
            else:
                # No profile photo; send text message only
                await update.message.reply_text(
                    welcome_text,
                    parse_mode='Markdown',
                    reply_markup=reply_markup
                )

        except Exception as e:
            # Fallback to sending just text if any error occurs
            print(f"Error fetching profile photo: {e}")
            await update.message.reply_text(
                welcome_text,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )


    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Send help message when the command /help is issued."""
        user = update.effective_user
        help_text = f"""
üìñ *How to use this bot:*

‚Ä¢ {user.full_name} üëáüèª

The bot will attempt to send a password reset request to the provided identifier.

Send: `/reset <username or email>`

‚ÄºÔ∏è* For any query Contact: Developer*

        """

        keyboard = [
            [InlineKeyboardButton("üì¢ Channel", url=f"https://t.me/{channel}"),
            InlineKeyboardButton("üë®‚Äçüíª Developer", url=f"https://t.me/{developer}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(help_text, parse_mode='Markdown', reply_markup=reply_markup)


    async def reset_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle the /reset command with arguments."""
        user = update.effective_user
        if not context.args:
            await update.message.reply_text(
                "‚ùå *Usage:* `/reset <username or email>`\n\nExample:\n`/reset username`\n`/reset email@example.com`\n`/reset @username`",
                parse_mode='Markdown'
            )
            return
        
        target = ' '.join(context.args).strip()
        
        # Show typing action
        await update.message.chat.send_action(action="typing")
        await update.message.reply_text(f"*Trying to reset:* `{target}`\nüë§ *Requested by:*  (@{user.username if user.username else ' '})",parse_mode="MarkDown"),
        
        # Process the request
        result = await self.process_password_reset(target)
        
        # Send the result back to user
        await update.message.reply_text(result, parse_mode='Markdown',reply_to_message_id=update.message.message_id)

        
    async def handle_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle the user's email/username input when sent as plain message."""
        user_input = update.message.text.strip()
        
        # Show typing action
        await update.message.chat.send_action(action="typing")
        
        # Process the request
        result = await self.process_password_reset(user_input)
        
        # Send the result back to user
        await update.message.reply_text(result, parse_mode='Markdown')
    
    def clean_target(self, target: str) -> str:
        """Clean the target input by removing @ symbol if present."""
        # Remove @ symbol from beginning if present
        if target.startswith('@'):
            return target[1:]
        return target
    
    async def process_password_reset(self, target: str):
        """Process the password reset request."""
        try:
            # Clean the target input
            cleaned_target = self.clean_target(target)
            
            if not cleaned_target:
                return "‚ùå Please provide a valid username or email address"
            
            if "@" in cleaned_target:
                data = {
                    "_csrftoken": "".join(
                        random.choices(string.ascii_lowercase + 
                                     string.ascii_uppercase + string.digits, k=32)
                    ),
                    "user_email": cleaned_target,
                    "guid": str(uuid.uuid4()),
                    "device_id": str(uuid.uuid4())
                }
                target_type = "email"
            else:
                data = {
                    "_csrftoken": "".join(
                        random.choices(string.ascii_lowercase + 
                                     string.ascii_uppercase + string.digits, k=32)
                    ),
                    "username": cleaned_target,
                    "guid": str(uuid.uuid4()),
                    "device_id": str(uuid.uuid4())
                }
                target_type = "username"
            
            return await self.send_password_reset(data, cleaned_target, target_type)
            
        except Exception as e:
            logger.error(f"Error processing request: {e}")
            return f"‚ùå Error occurred: {str(e)}"
    
    async def send_password_reset(self, data: dict, target: str, target_type: str):
        """Send the password reset request to Instagram API."""
        try:
            headers = {
                "user-agent": f"Instagram 150.0.0.0.000 Android (29/10; 300dpi; 720x1440; {''.join(random.choices(string.ascii_lowercase+string.digits, k=16))}/{''.join(random.choices(string.ascii_lowercase+string.digits, k=16))}; {''.join(random.choices(string.ascii_lowercase+string.digits, k=16))}; {''.join(random.choices(string.ascii_lowercase+string.digits, k=16))}; {''.join(random.choices(string.ascii_lowercase+string.digits, k=16))}; en_GB;)"
            }
            
            response = requests.post(
                "https://i.instagram.com/api/v1/accounts/send_password_reset/",
                headers=headers,
                data=data,
                timeout=10
            )
            
            if response.status_code == 200:
                if "obfuscated_email" in response.text:
                    return (
                        f"‚úÖ *Success!*\n"
                        f"Target: `{target}`\n"
                        f"Status: `Password reset sent successfully`\n\n"
                        f"Response:\n```{response.text}```"
                    )
                else:
                    return (
                        f"‚ùå *Failed!*\n"
                        f"Target: `{target}`\n"
                        f"Status: `No obfuscated email in response`\n\n"
                        f"Response: ```{response.text}```"
                    )
            else:
                return (
                    f"‚ùå *HTTP Error {response.status_code}*\n"
                    f"Target: `{target}`\n\n"
                    f"Response: \n```{response.text}```"
                )
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Request error: {e}")
            return (
                f"‚ùå *Network Error*\n"
                f"Target: `{target}`\n"
                f"Error: `Could not connect to Instagram servers`\n\n"
                f"Details: `{str(e)}`"
            )
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            return f"‚ùå *Unexpected Error*\nTarget: `{target}`\nError: `{str(e)}`"

def main():
    """Start the bot."""
    # Get the token from environment variable
    
    
    # Create and run the bot
    bot = InstagramPasswordResetBot(TOKEN)
    
    print("ü§ñ Bot is running...")
    print("Press Ctrl+C to stop")
    
    # Start the Bot
    bot.application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
